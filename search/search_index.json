{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"trivia-game","text":"<p>Trivia Game</p>"},{"location":"modules/","title":"Modules","text":"<p>Module for interacting with the trivia API.</p> <p>Models for the trivia game.</p> <p>Module for Trivia API exceptions</p> <p>Module for interacting with the trivia API.</p> <p>BaseFrame class module</p> <p>ScoreboardFrame class module</p>"},{"location":"modules/#trivia_game.trivia_api.TriviaAPIClient","title":"<code>TriviaAPIClient</code>","text":"<p>Client for handling Trivia API interactions</p> <p>Attributes:</p> Name Type Description <code>QUESTIONS_API_URL</code> <code>ClassVar[str]</code> <p>The URL for fetching questions</p> <code>SESSION_TOKEN_API_URL</code> <code>ClassVar[str]</code> <p>The URL for fetching session tokens</p> <code>CATEGORIES_API_URL</code> <code>str</code> <p>The URL for fetching categories</p> <code>ERROR_MESSAGES</code> <code>ClassVar[dict[int, str]]</code> <p>Error messages for API response codes</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Timeout for requests. Defaults to 10.</p> <code>10</code> <code>retries</code> <code>int</code> <p>Number of retries for failed requests. Defaults to 3.</p> <code>3</code> <p>Raises:</p> Type Description <code>TriviaAPIError</code> <p>If an unknown error occurs</p> <code>NoResultsError</code> <p>If there are not enough questions available</p> <code>InvalidParameterError</code> <p>If invalid parameters are provided</p> <code>TokenError</code> <p>If a session token is not found or is empty</p> <code>RateLimitError</code> <p>If the rate limit is exceeded</p> Source code in <code>trivia_game/trivia_api.py</code> <pre><code>class TriviaAPIClient:\n    \"\"\"Client for handling Trivia API interactions\n\n    Attributes:\n        QUESTIONS_API_URL (ClassVar[str]): The URL for fetching questions\n        SESSION_TOKEN_API_URL (ClassVar[str]): The URL for fetching session tokens\n        CATEGORIES_API_URL (str): The URL for fetching categories\n        ERROR_MESSAGES (ClassVar[dict[int, str]]): Error messages for API response codes\n\n    Args:\n        timeout (int, optional): Timeout for requests. Defaults to 10.\n        retries (int, optional): Number of retries for failed requests. Defaults to 3.\n\n    Raises:\n        TriviaAPIError: If an unknown error occurs\n        NoResultsError: If there are not enough questions available\n        InvalidParameterError: If invalid parameters are provided\n        TokenError: If a session token is not found or is empty\n        RateLimitError: If the rate limit is exceeded\n    \"\"\"\n\n    QUESTIONS_API_URL: ClassVar[str] = \"https://opentdb.com/api.php\"\n    SESSION_TOKEN_API_URL: ClassVar[str] = \"https://opentdb.com/api_token.php\"\n    CATEGORIES_API_URL: ClassVar[str] = \"https://opentdb.com/api_category.php\"\n\n    ERROR_MESSAGES: ClassVar[dict[int, str]] = {\n        TriviaResponseCode.NO_RESULTS: \"Not enough questions available for your query\",\n        TriviaResponseCode.INVALID_PARAMETER: \"Invalid parameters provided\",\n        TriviaResponseCode.TOKEN_NOT_FOUND: \"Session token not found\",\n        TriviaResponseCode.TOKEN_EMPTY: \"Token has returned all possible questions\",\n        TriviaResponseCode.RATE_LIMIT: \"Rate limit exceeded. Please wait 5 seconds\",\n    }\n\n    HTTP_ERROR_MAPPING: ClassVar[dict[int, tuple[type[Exception], str]]] = {\n        400: (InvalidParameterError, \"Bad Request\"),\n        401: (TriviaAPIError, \"Authentication required\"),\n        403: (TriviaAPIError, \"Access denied\"),\n        404: (TriviaAPIError, \"Resource not found\"),\n        429: (RateLimitError, \"Rate limit exceeded\"),\n        500: (TriviaAPIError, \"Internal Server Error\"),\n        502: (TriviaAPIError, \"Bad Gateway\"),\n        503: (TriviaAPIError, \"Service Unavailable\"),\n        504: (TriviaAPIError, \"Gateway Timeout\"),\n    }\n\n    REQUEST_ERROR_MAPPING: ClassVar[dict[type[Exception], tuple[type[Exception], str]]] = {\n        requests.exceptions.ConnectionError: (TriviaAPIError, \"Connection error\"),\n        requests.exceptions.Timeout: (TriviaAPIError, \"Request timed out\"),\n        requests.exceptions.JSONDecodeError: (TriviaAPIError, \"Invalid JSON response\"),\n        requests.exceptions.RequestException: (TriviaAPIError, \"Generic error\"),\n    }\n\n    def __init__(self, timeout: int = 10, retries: int = 3) -&gt; None:\n        \"\"\"Initialize the TriviaAPIClient\n\n        Args:\n            timeout (int, optional): Timeout for requests. Defaults to 10.\n            retries (int, optional): Number of retries for failed requests. Defaults to 3.\n\n        Returns:\n            None\n        \"\"\"\n\n        self.timeout = timeout\n        self._session_token: str | None = None\n        self.session = self._create_session(retries)\n        self._session_token = self.request_session_token()\n        self.categories: dict[str, str] = {}\n\n    def _create_session(self, retries: int) -&gt; requests.Session:\n        \"\"\"Create and configure requests session\n\n        Args:\n            retries (int): Number of retries for failed requests\n\n        Returns:\n            requests.Session: The configured session\n        \"\"\"\n        session: requests.Session = requests.Session()\n\n        retry_strategy: Retry = Retry(\n            total=retries,\n            backoff_factor=5,\n            status_forcelist=[429, 500, 502, 503, 504],\n            allowed_methods=[\"GET\"],\n        )\n        adapter: HTTPAdapter = HTTPAdapter(max_retries=retry_strategy)\n        session.mount(\"http://\", adapter)\n        session.mount(\"https://\", adapter)\n        return session\n\n    def _handle_response_code(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"Handle response code from Trivia API\n\n        Args:\n            data (dict[str, Any]): The JSON response data\n\n        Raises:\n            TriviaAPIError: If an unknown error occurs\n            NoResultsError: If there are not enough questions available\n            InvalidParameterError: If invalid parameters are provided\n            TokenError: If a session token is not found or is empty\n            RateLimitError: If the rate limit is exceeded\n\n        Returns:\n            None\n        \"\"\"\n        response_code: int | None = data.get(\"response_code\")\n\n        if response_code is None:\n            msg: str = \"Response code not found in API response\"\n            raise TriviaAPIError(msg)\n\n        if response_code == TriviaResponseCode.SUCCESS:\n            return\n\n        error_message = self.ERROR_MESSAGES.get(response_code, f\"Unknown error occurred: {response_code}\")\n\n        if response_code == TriviaResponseCode.NO_RESULTS:\n            raise NoResultsError(error_message)\n        elif response_code == TriviaResponseCode.INVALID_PARAMETER:\n            raise InvalidParameterError(error_message)\n        elif response_code in (TriviaResponseCode.TOKEN_NOT_FOUND, TriviaResponseCode.TOKEN_EMPTY):\n            raise TokenError(error_message)\n        elif response_code == TriviaResponseCode.RATE_LIMIT:\n            raise RateLimitError(error_message)\n        else:\n            raise TriviaAPIError(error_message)\n\n    def _parse_and_validate_response(self, response: requests.Response) -&gt; dict[str, Any]:\n        \"\"\"Parse and validate JSON response from API\n\n        Args:\n            response (requests.Response): The HTTP response object\n\n        Raises:\n            TriviaAPIError: If the JSON response is invalid\n\n        Returns:\n            dict[str, Any]: The JSON response data\n        \"\"\"\n        try:\n            data: dict[str, Any] = response.json()\n\n        except requests.exceptions.JSONDecodeError as e:\n            error_msg: str = f\"Invalid JSON response: {e!s}\"\n            raise TriviaAPIError(error_msg) from e\n\n        if \"response_code\" in data:\n            self._handle_response_code(data)\n\n        # Check for empty token only if token field exists\n        if \"token\" in data and not data[\"token\"]:\n            token_err_msg: str = \"Invalid token received\"\n            raise TokenError(token_err_msg)\n\n        return data\n\n    def _make_request(self, url: str, params: dict[str, Any] | None = None) -&gt; dict[str, Any]:\n        \"\"\"Make HTTP request with error handling\"\"\"\n\n        try:\n            response: requests.Response = self.session.get(url, params=params, timeout=self.timeout)\n            response.raise_for_status()\n\n        except requests.exceptions.HTTPError as e:\n            status_code: int = e.response.status_code\n            error_class, error_msg = self.HTTP_ERROR_MAPPING.get(status_code, (TriviaAPIError, f\"HTTP {status_code}\"))\n            http_err_msg: str = f\"Request failed: {error_msg}\"\n            raise error_class(http_err_msg) from e\n\n        except tuple(self.REQUEST_ERROR_MAPPING.keys()) as e:\n            error_class, error_msg = self.REQUEST_ERROR_MAPPING[type(e)]\n            request_err_msg: str = f\"Request failed: {error_msg}\"\n            raise error_class(request_err_msg) from e\n\n        else:\n            return self._parse_and_validate_response(response)\n\n    def request_session_token(self) -&gt; str:\n        \"\"\"Request a session token from the API\n\n        Raises:\n            TriviaAPIError: If the request fails\n\n        Returns:\n            str: The session token value\n        \"\"\"\n        params: dict[str, str] = {\"command\": \"request\"}\n        data: dict[str, Any] = self._make_request(self.SESSION_TOKEN_API_URL, params=params)\n        return cast(str, data[\"token\"])\n\n    def reset_session_token(self) -&gt; str:\n        \"\"\"Reset the current session token.\n\n        This will wipe all progress/question history for the current token\n        but return the same token value. Use this when you've exhausted\n        all questions for a given category/difficulty combination.\n\n        Raises:\n            TokenError: If no active session token exists\n            TriviaAPIError: If the reset request fails\n\n        Returns:\n            str: The same token value, but with progress wiped\n        \"\"\"\n        if not self._session_token:\n            msg: str = \"Cannot reset: No active session token\"\n            raise TokenError(msg)\n\n        params: dict[str, str] = {\"command\": \"reset\", \"token\": self._session_token}\n        data: dict[str, Any] = self._make_request(self.SESSION_TOKEN_API_URL, params=params)\n        return cast(str, data[\"token\"])\n\n    def _validate_token(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"Validate the session token in the API response\n\n        Args:\n            data (dict[str, Any]): The API response data\n\n        Raises:\n            TokenError: If the token is invalid or empty\n\n        Returns:\n            None\n        \"\"\"\n        if \"token\" in data and not data[\"token\"]:\n            msg: str = \"Invalid token received\"\n            raise TokenError(msg)\n\n    @staticmethod\n    def _decode_text(text: str) -&gt; str:\n        \"\"\"Decode URL-encoded text\n\n        Args:\n            text (str): The URL-encoded text\n\n        Returns:\n            str: The decoded text\n        \"\"\"\n        return html.unescape(unquote(text))\n\n    def _format_question(self, data: dict[str, Any]) -&gt; Question:\n        \"\"\"Format and decode question data from API response\n\n        Args:\n            data (dict[str, Any]): The question data from the API\n\n        Returns:\n            Question: The formatted question object\n        \"\"\"\n        difficulty: str = self._decode_text(data[\"difficulty\"])\n\n        if difficulty not in (\"easy\", \"medium\", \"hard\"):\n            difficulty_err_msg: str = f\"Invalid difficulty value: {difficulty}\"\n            raise InvalidParameterError(difficulty_err_msg)\n\n        return Question(\n            type=cast(QuestionType, self._decode_text(data[\"type\"])),\n            difficulty=cast(DifficultyType, difficulty),\n            category=self._decode_text(data[\"category\"]),\n            question=self._decode_text(data[\"question\"]),\n            correct_answer=self._decode_text(data[\"correct_answer\"]),\n            incorrect_answers=[self._decode_text(answer) for answer in data[\"incorrect_answers\"]],\n        )\n\n    def fetch_categories(self) -&gt; dict[str, str]:\n        \"\"\"Fetch trivia categories from the API\n\n        Raises:\n            CategoryError: If the request fails or no categories are found\n\n        Returns:\n            dict[str, str]: The categories as a dict of name: id\n        \"\"\"\n\n        try:\n            data = self._make_request(self.CATEGORIES_API_URL)\n\n            if not data.get(\"trivia_categories\"):\n                category_error_msg = \"No categories found in API response\"\n                raise CategoryError(category_error_msg)\n\n            self.categories = {\n                category[\"name\"]: str(category[\"id\"])\n                for category in data[\"trivia_categories\"]\n                if category.get(\"name\") and category.get(\"id\")\n            }\n\n        except TriviaAPIError as e:\n            error_msg: str = f\"Failed to fetch categories: {e!s}\"\n            raise CategoryError(error_msg) from e\n\n        else:\n            return self.categories\n\n    def fetch_questions(\n        self,\n        amount: int = 10,\n        category: str | None = None,\n        difficulty: DifficultyType | None = None,\n        question_type: QuestionType | None = None,\n        max_retries: int = 3,\n    ) -&gt; list[Question]:\n        \"\"\"Fetch trivia questions from the API.\n\n        Args:\n            amount (int, optional): The number of questions to fetch. Defaults to 10.\n            category (str, optional): The category to fetch questions from. Defaults to None.\n            difficulty (str, optional): The difficulty level of the questions. Defaults to None.\n            question_type (str, optional): The type of questions to fetch. Defaults to None.\n            max_retries (int, optional): The maximum number of retries for token reset. Defaults to 3.\n        Raises:\n            InvalidParameterError: If invalid parameters are provided\n            TokenError: If the session token is not found or is empty\n            NoResultsError: If there are not enough questions available\n            RateLimitError: If the rate limit is exceeded\n\n        Returns:\n            list[Question]: The list of formatted question objects\n        \"\"\"\n\n        if amount &lt; 1 or amount &gt; 50:\n            msg: str = \"Amount must be between 1 and 50\"\n            raise InvalidParameterError(msg)\n\n        params: dict[str, str | None] = {\n            \"amount\": str(amount),\n            \"token\": self._session_token,\n        }\n\n        if category:\n            params[\"category\"] = category\n        if difficulty:\n            params[\"difficulty\"] = difficulty\n        if question_type:\n            params[\"type\"] = question_type\n\n        retry_count: int = 0\n        retry_count_err_msg: str = \"Maximum retry attempts reached for token reset\"\n\n        while retry_count &lt;= max_retries:\n            try:\n                data: dict[str, Any] = self._make_request(self.QUESTIONS_API_URL, params=params)\n\n            except TokenError as e:\n                if \"Token has returned all possible questions\" not in str(e):\n                    raise\n                if retry_count &gt;= max_retries:\n                    raise TokenError(retry_count_err_msg) from e\n                self._session_token = self.reset_session_token()\n                retry_count += 1\n            else:\n                return [self._format_question(question) for question in data[\"results\"]]\n\n        raise TokenError(retry_count_err_msg)\n\n    def __enter__(self) -&gt; \"TriviaAPIClient\":\n        \"\"\"Enter context manager\n\n        Returns:\n            TriviaAPIClient: The client instance\n        \"\"\"\n        return self\n\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None\n    ) -&gt; None:\n        \"\"\"Close the session when exiting the context manager.\n\n        Args:\n            exc_type: The type of the exception that was raised\n            exc_val: The instance of the exception that was raised\n            exc_tb: The traceback of the exception that was raised\n\n        Returns:\n            None\n        \"\"\"\n        self.session.close()\n</code></pre>"},{"location":"modules/#trivia_game.trivia_api.TriviaAPIClient.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter context manager</p> <p>Returns:</p> Name Type Description <code>TriviaAPIClient</code> <code>TriviaAPIClient</code> <p>The client instance</p> Source code in <code>trivia_game/trivia_api.py</code> <pre><code>def __enter__(self) -&gt; \"TriviaAPIClient\":\n    \"\"\"Enter context manager\n\n    Returns:\n        TriviaAPIClient: The client instance\n    \"\"\"\n    return self\n</code></pre>"},{"location":"modules/#trivia_game.trivia_api.TriviaAPIClient.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Close the session when exiting the context manager.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>type[BaseException] | None</code> <p>The type of the exception that was raised</p> required <code>exc_val</code> <code>BaseException | None</code> <p>The instance of the exception that was raised</p> required <code>exc_tb</code> <code>TracebackType | None</code> <p>The traceback of the exception that was raised</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>trivia_game/trivia_api.py</code> <pre><code>def __exit__(\n    self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None\n) -&gt; None:\n    \"\"\"Close the session when exiting the context manager.\n\n    Args:\n        exc_type: The type of the exception that was raised\n        exc_val: The instance of the exception that was raised\n        exc_tb: The traceback of the exception that was raised\n\n    Returns:\n        None\n    \"\"\"\n    self.session.close()\n</code></pre>"},{"location":"modules/#trivia_game.trivia_api.TriviaAPIClient.__init__","title":"<code>__init__(timeout=10, retries=3)</code>","text":"<p>Initialize the TriviaAPIClient</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Timeout for requests. Defaults to 10.</p> <code>10</code> <code>retries</code> <code>int</code> <p>Number of retries for failed requests. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>trivia_game/trivia_api.py</code> <pre><code>def __init__(self, timeout: int = 10, retries: int = 3) -&gt; None:\n    \"\"\"Initialize the TriviaAPIClient\n\n    Args:\n        timeout (int, optional): Timeout for requests. Defaults to 10.\n        retries (int, optional): Number of retries for failed requests. Defaults to 3.\n\n    Returns:\n        None\n    \"\"\"\n\n    self.timeout = timeout\n    self._session_token: str | None = None\n    self.session = self._create_session(retries)\n    self._session_token = self.request_session_token()\n    self.categories: dict[str, str] = {}\n</code></pre>"},{"location":"modules/#trivia_game.trivia_api.TriviaAPIClient.fetch_categories","title":"<code>fetch_categories()</code>","text":"<p>Fetch trivia categories from the API</p> <p>Raises:</p> Type Description <code>CategoryError</code> <p>If the request fails or no categories are found</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: The categories as a dict of name: id</p> Source code in <code>trivia_game/trivia_api.py</code> <pre><code>def fetch_categories(self) -&gt; dict[str, str]:\n    \"\"\"Fetch trivia categories from the API\n\n    Raises:\n        CategoryError: If the request fails or no categories are found\n\n    Returns:\n        dict[str, str]: The categories as a dict of name: id\n    \"\"\"\n\n    try:\n        data = self._make_request(self.CATEGORIES_API_URL)\n\n        if not data.get(\"trivia_categories\"):\n            category_error_msg = \"No categories found in API response\"\n            raise CategoryError(category_error_msg)\n\n        self.categories = {\n            category[\"name\"]: str(category[\"id\"])\n            for category in data[\"trivia_categories\"]\n            if category.get(\"name\") and category.get(\"id\")\n        }\n\n    except TriviaAPIError as e:\n        error_msg: str = f\"Failed to fetch categories: {e!s}\"\n        raise CategoryError(error_msg) from e\n\n    else:\n        return self.categories\n</code></pre>"},{"location":"modules/#trivia_game.trivia_api.TriviaAPIClient.fetch_questions","title":"<code>fetch_questions(amount=10, category=None, difficulty=None, question_type=None, max_retries=3)</code>","text":"<p>Fetch trivia questions from the API.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>The number of questions to fetch. Defaults to 10.</p> <code>10</code> <code>category</code> <code>str</code> <p>The category to fetch questions from. Defaults to None.</p> <code>None</code> <code>difficulty</code> <code>str</code> <p>The difficulty level of the questions. Defaults to None.</p> <code>None</code> <code>question_type</code> <code>str</code> <p>The type of questions to fetch. Defaults to None.</p> <code>None</code> <code>max_retries</code> <code>int</code> <p>The maximum number of retries for token reset. Defaults to 3.</p> <code>3</code> <p>Raises:     InvalidParameterError: If invalid parameters are provided     TokenError: If the session token is not found or is empty     NoResultsError: If there are not enough questions available     RateLimitError: If the rate limit is exceeded</p> <p>Returns:</p> Type Description <code>list[Question]</code> <p>list[Question]: The list of formatted question objects</p> Source code in <code>trivia_game/trivia_api.py</code> <pre><code>def fetch_questions(\n    self,\n    amount: int = 10,\n    category: str | None = None,\n    difficulty: DifficultyType | None = None,\n    question_type: QuestionType | None = None,\n    max_retries: int = 3,\n) -&gt; list[Question]:\n    \"\"\"Fetch trivia questions from the API.\n\n    Args:\n        amount (int, optional): The number of questions to fetch. Defaults to 10.\n        category (str, optional): The category to fetch questions from. Defaults to None.\n        difficulty (str, optional): The difficulty level of the questions. Defaults to None.\n        question_type (str, optional): The type of questions to fetch. Defaults to None.\n        max_retries (int, optional): The maximum number of retries for token reset. Defaults to 3.\n    Raises:\n        InvalidParameterError: If invalid parameters are provided\n        TokenError: If the session token is not found or is empty\n        NoResultsError: If there are not enough questions available\n        RateLimitError: If the rate limit is exceeded\n\n    Returns:\n        list[Question]: The list of formatted question objects\n    \"\"\"\n\n    if amount &lt; 1 or amount &gt; 50:\n        msg: str = \"Amount must be between 1 and 50\"\n        raise InvalidParameterError(msg)\n\n    params: dict[str, str | None] = {\n        \"amount\": str(amount),\n        \"token\": self._session_token,\n    }\n\n    if category:\n        params[\"category\"] = category\n    if difficulty:\n        params[\"difficulty\"] = difficulty\n    if question_type:\n        params[\"type\"] = question_type\n\n    retry_count: int = 0\n    retry_count_err_msg: str = \"Maximum retry attempts reached for token reset\"\n\n    while retry_count &lt;= max_retries:\n        try:\n            data: dict[str, Any] = self._make_request(self.QUESTIONS_API_URL, params=params)\n\n        except TokenError as e:\n            if \"Token has returned all possible questions\" not in str(e):\n                raise\n            if retry_count &gt;= max_retries:\n                raise TokenError(retry_count_err_msg) from e\n            self._session_token = self.reset_session_token()\n            retry_count += 1\n        else:\n            return [self._format_question(question) for question in data[\"results\"]]\n\n    raise TokenError(retry_count_err_msg)\n</code></pre>"},{"location":"modules/#trivia_game.trivia_api.TriviaAPIClient.request_session_token","title":"<code>request_session_token()</code>","text":"<p>Request a session token from the API</p> <p>Raises:</p> Type Description <code>TriviaAPIError</code> <p>If the request fails</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The session token value</p> Source code in <code>trivia_game/trivia_api.py</code> <pre><code>def request_session_token(self) -&gt; str:\n    \"\"\"Request a session token from the API\n\n    Raises:\n        TriviaAPIError: If the request fails\n\n    Returns:\n        str: The session token value\n    \"\"\"\n    params: dict[str, str] = {\"command\": \"request\"}\n    data: dict[str, Any] = self._make_request(self.SESSION_TOKEN_API_URL, params=params)\n    return cast(str, data[\"token\"])\n</code></pre>"},{"location":"modules/#trivia_game.trivia_api.TriviaAPIClient.reset_session_token","title":"<code>reset_session_token()</code>","text":"<p>Reset the current session token.</p> <p>This will wipe all progress/question history for the current token but return the same token value. Use this when you've exhausted all questions for a given category/difficulty combination.</p> <p>Raises:</p> Type Description <code>TokenError</code> <p>If no active session token exists</p> <code>TriviaAPIError</code> <p>If the reset request fails</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The same token value, but with progress wiped</p> Source code in <code>trivia_game/trivia_api.py</code> <pre><code>def reset_session_token(self) -&gt; str:\n    \"\"\"Reset the current session token.\n\n    This will wipe all progress/question history for the current token\n    but return the same token value. Use this when you've exhausted\n    all questions for a given category/difficulty combination.\n\n    Raises:\n        TokenError: If no active session token exists\n        TriviaAPIError: If the reset request fails\n\n    Returns:\n        str: The same token value, but with progress wiped\n    \"\"\"\n    if not self._session_token:\n        msg: str = \"Cannot reset: No active session token\"\n        raise TokenError(msg)\n\n    params: dict[str, str] = {\"command\": \"reset\", \"token\": self._session_token}\n    data: dict[str, Any] = self._make_request(self.SESSION_TOKEN_API_URL, params=params)\n    return cast(str, data[\"token\"])\n</code></pre>"},{"location":"modules/#trivia_game.models.Category","title":"<code>Category</code>  <code>dataclass</code>","text":"<p>Dataclass for a trivia category.</p> Source code in <code>trivia_game/models.py</code> <pre><code>@dataclass\nclass Category:\n    \"\"\"Dataclass for a trivia category.\"\"\"\n\n    id: str\n    name: str\n</code></pre>"},{"location":"modules/#trivia_game.models.Question","title":"<code>Question</code>  <code>dataclass</code>","text":"<p>Dataclass for a trivia question.</p> Source code in <code>trivia_game/models.py</code> <pre><code>@dataclass\nclass Question:\n    \"\"\"Dataclass for a trivia question.\"\"\"\n\n    type: QuestionType\n    difficulty: DifficultyType\n    category: str\n    question: str\n    correct_answer: str\n    incorrect_answers: list[str]\n\n    def all_answers(self) -&gt; list[str]:\n        \"\"\"Return all answers including correct and incorrect ones.\n\n        Returns:\n            list[str]: All answers\n        \"\"\"\n        return [self.correct_answer, *self.incorrect_answers]\n</code></pre>"},{"location":"modules/#trivia_game.models.Question.all_answers","title":"<code>all_answers()</code>","text":"<p>Return all answers including correct and incorrect ones.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: All answers</p> Source code in <code>trivia_game/models.py</code> <pre><code>def all_answers(self) -&gt; list[str]:\n    \"\"\"Return all answers including correct and incorrect ones.\n\n    Returns:\n        list[str]: All answers\n    \"\"\"\n    return [self.correct_answer, *self.incorrect_answers]\n</code></pre>"},{"location":"modules/#trivia_game.models.TriviaResponseCode","title":"<code>TriviaResponseCode</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum for trivia API response codes.</p> Source code in <code>trivia_game/models.py</code> <pre><code>class TriviaResponseCode(IntEnum):\n    \"\"\"Enum for trivia API response codes.\"\"\"\n\n    SUCCESS: int = 0\n    NO_RESULTS: int = 1\n    INVALID_PARAMETER: int = 2\n    TOKEN_NOT_FOUND: int = 3\n    TOKEN_EMPTY: int = 4\n    RATE_LIMIT: int = 5\n</code></pre>"},{"location":"modules/#trivia_game.exceptions.CategoryError","title":"<code>CategoryError</code>","text":"<p>               Bases: <code>TriviaAPIError</code></p> <p>Exception for category-related errors</p> Source code in <code>trivia_game/exceptions.py</code> <pre><code>class CategoryError(TriviaAPIError):\n    \"\"\"Exception for category-related errors\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/#trivia_game.exceptions.InvalidParameterError","title":"<code>InvalidParameterError</code>","text":"<p>               Bases: <code>TriviaAPIError</code></p> <p>Invalid parameters provided</p> Source code in <code>trivia_game/exceptions.py</code> <pre><code>class InvalidParameterError(TriviaAPIError):\n    \"\"\"Invalid parameters provided\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/#trivia_game.exceptions.NoResultsError","title":"<code>NoResultsError</code>","text":"<p>               Bases: <code>TriviaAPIError</code></p> <p>Not enough questions available</p> Source code in <code>trivia_game/exceptions.py</code> <pre><code>class NoResultsError(TriviaAPIError):\n    \"\"\"Not enough questions available\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/#trivia_game.exceptions.RateLimitError","title":"<code>RateLimitError</code>","text":"<p>               Bases: <code>TriviaAPIError</code></p> <p>Rate limit exceeded</p> Source code in <code>trivia_game/exceptions.py</code> <pre><code>class RateLimitError(TriviaAPIError):\n    \"\"\"Rate limit exceeded\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/#trivia_game.exceptions.TokenError","title":"<code>TokenError</code>","text":"<p>               Bases: <code>TriviaAPIError</code></p> <p>Token-related errors</p> Source code in <code>trivia_game/exceptions.py</code> <pre><code>class TokenError(TriviaAPIError):\n    \"\"\"Token-related errors\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/#trivia_game.exceptions.TriviaAPIError","title":"<code>TriviaAPIError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for Trivia API errors</p> Source code in <code>trivia_game/exceptions.py</code> <pre><code>class TriviaAPIError(Exception):\n    \"\"\"Base exception for Trivia API errors\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/#trivia_game.quiz_brain.QuizBrain","title":"<code>QuizBrain</code>","text":"<p>               Bases: <code>TriviaGameProtocol</code></p> Source code in <code>trivia_game/quiz_brain.py</code> <pre><code>class QuizBrain(TriviaGameProtocol):\n    # Mapping of question types to API-compatible values\n    TYPE_MAPPING: ClassVar[dict[str, str | None]] = {\n        \"Any Type\": None,\n        \"Multiple Choice\": \"multiple\",\n        \"True / False\": \"boolean\",\n    }\n\n    DIFFICULTY_MULTIPLIER: ClassVar[dict[str, int]] = {\"easy\": 1, \"medium\": 2, \"hard\": 3}\n\n    def __init__(self, controller: AppControllerProtocol) -&gt; None:\n        \"\"\"Create the quiz brain object\n\n        Args:\n            controller (AppControllerProtocol): The main application controller\n\n        Attributes:\n        controller (AppControllerProtocol): The main application controller\n        api_client (TriviaAPIClient): The API client\n        categories (dict[str, str]): The trivia categories\n        current_question (Question | None): The current question\n        questions (list[Question]): The list of questions for the current game\n        score (int): The current score\n        TYPE_MAPPING (ClassVar[dict[str, str | None]]): Mapping of question types to API-compatible values\n        DIFFICULTY_MULTIPLIER (ClassVar[dict[str, int]]): Difficulty level multipliers\n        \"\"\"\n\n        self.controller: AppControllerProtocol = controller\n        self.api_client: TriviaAPIClient = TriviaAPIClient()\n\n        self.categories: dict[str, str] = {}\n        self.current_question: Question | None = None\n        self.questions: list[Question] = []\n        self.score: int = 0\n\n        self._load_categories()\n\n    def _load_categories(self) -&gt; None:\n        \"\"\"Load trivia categories from the API\"\"\"\n        try:\n            self.categories = self.api_client.fetch_categories()\n        except CategoryError as e:\n            self.controller.show_error(f\"Error loading categories: {e}. Please try again later.\")\n\n    def get_available_categories(self) -&gt; list[str]:\n        \"\"\"Get list of available categories including 'Any Category' option\n\n        Returns:\n            list[str]: The categories with the 'Any Category' option\n        \"\"\"\n        categories: list[str] = [\"Any Category\"]\n        categories.extend(sorted(self.categories.keys()))\n\n        return categories\n\n    def get_category_id(self, category_name: str) -&gt; str | None:\n        \"\"\"Get category ID for selected category name\n\n        Args:\n            category_name (str): The category name\n\n        Returns:\n            str | None: The category ID or None if 'Any Category'\n\n        \"\"\"\n        return None if category_name == \"Any Category\" else self.categories[category_name]\n\n    def get_available_difficulties(self) -&gt; list[str]:\n        \"\"\"Get list of available difficulty levels\n\n        Returns:\n            list[str]: The difficulties\n\n        \"\"\"\n        return [\"Any Difficulty\", \"Easy\", \"Medium\", \"Hard\"]\n\n    def get_difficulty_value(self, difficulty_name: str) -&gt; Literal[\"easy\", \"medium\", \"hard\"] | None:\n        \"\"\"Get API-compatible difficulty value\n\n        Args:\n            difficulty_name (str): The difficulty name\n\n        Returns:\n            Literal[\"easy\", \"medium\", \"hard\"] | None: The difficulty value or None if 'Any Difficulty'\n        \"\"\"\n        return None if difficulty_name == \"Any Difficulty\" else difficulty_name.lower()  # type: ignore[return-value]\n\n    def get_available_question_types(self) -&gt; list[str]:\n        \"\"\"Get list of available question types\n\n        Returns:\n            list[str]: The question types\n\n        \"\"\"\n        return [\"Any Type\", \"Multiple Choice\", \"True / False\"]\n\n    def get_question_type_value(self, question_type: str) -&gt; str | None:\n        \"\"\"Get API-compatible question type value\n\n        Args:\n            question_type (str): The question type\n\n        Returns:\n            str | None: The question type value or None if 'Any Type'\n\n        \"\"\"\n        return self.TYPE_MAPPING[question_type]\n\n    def load_questions(\n        self,\n        category: str | None,\n        difficulty: Literal[\"easy\", \"medium\", \"hard\"] | None,\n        question_type: Literal[\"multiple\", \"boolean\"] | None,\n    ) -&gt; None:\n        \"\"\"Load questions from the API\n\n        Args:\n            category (str | None): The category ID or None for 'Any Category'\n            difficulty (Literal[\"easy\", \"medium\", \"hard\"] | None): The difficulty level or None for 'Any Difficulty'\n            question_type (Literal[\"multiple\", \"boolean\"] | None): The question type or None for 'Any Type'\n        \"\"\"\n        try:\n            self.questions = self.api_client.fetch_questions(\n                category=category, difficulty=difficulty, question_type=question_type\n            )\n            self.score = 0\n            self.show_next_question()\n        except Exception as e:\n            msg: str = f\"Error loading questions: {e}\"\n            self.controller.show_error(msg)\n\n    def show_next_question(self) -&gt; None:\n        \"\"\"Show next question or end game if no more questions\"\"\"\n        if not self.questions:\n            print(\"No more questions, showing scoreboard\")  # TODO: Remove debug print\n            self.end_game()\n            return\n\n        self.current_question = self.questions.pop(0)\n        self.controller.show_frame(\n            \"TrueFalseQuizFrame\" if self.current_question.type == \"boolean\" else \"MultipleChoiceQuizFrame\"\n        )\n\n    def check_answer(self, selected_answer: str) -&gt; bool:\n        \"\"\"Check if selected answer is correct\n\n        Args:\n            selected_answer (str): The selected answer\n\n        Returns:\n            bool: True if correct, False otherwise\n        \"\"\"\n        if not self.current_question:\n            return False\n\n        is_correct: bool = selected_answer == self.current_question.correct_answer\n\n        if is_correct:\n            self.score += self._calculate_score(self.current_question.difficulty)\n        return is_correct\n\n    def _calculate_score(self, difficulty: str) -&gt; int:\n        \"\"\"Calculate score based on difficulty level\n\n        Args:\n            difficulty (str): The difficulty level\n\n        Returns:\n            int: Calculated score\n        \"\"\"\n        return 100 * self.DIFFICULTY_MULTIPLIER[difficulty]\n\n    def end_game(self) -&gt; None:\n        \"\"\"Handle game completion\"\"\"\n\n        dialog: ScoreDialog = ScoreDialog(self.controller, self.score)\n        if player_name := dialog.get_input():\n            self.save_score(player_name)\n\n            self.score = 0\n        self.controller.show_frame(\"ScoreboardFrame\")\n\n    def save_score(self, player_name: str) -&gt; None:\n        \"\"\"Save score to the scoreboard\"\"\"\n        entry = ScoreboardEntry(player_name, self.score, date=datetime.now())\n        print(entry)  # TODO: Remove debug print\n        self._save_to_json(entry)\n\n    def _save_to_json(self, entry: ScoreboardEntry) -&gt; None:\n        \"\"\"Save scoreboard entry to JSON file\n\n        Args:\n            entry (ScoreboardEntry): The scoreboard entry\n\n        \"\"\"\n        scores_file = Path(\"scores.json\")\n        if scores_file.exists():\n            with scores_file.open(\"r\") as f:\n                scores = json.load(f)\n        else:\n            scores = []\n\n        scores.append({\n            \"player\": entry.player_name,\n            \"score\": entry.score,\n            \"date\": entry.date.isoformat(),\n        })\n\n        # Keep only top 10 scores\n        scores.sort(key=lambda x: x[\"score\"], reverse=True)\n        scores = scores[:10]\n\n        with scores_file.open(\"w\") as f:\n            json.dump(scores, f, indent=2)\n\n        print(\"Score saved\")\n</code></pre>"},{"location":"modules/#trivia_game.quiz_brain.QuizBrain.__init__","title":"<code>__init__(controller)</code>","text":"<p>Create the quiz brain object</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>AppControllerProtocol</code> <p>The main application controller</p> required <p>Attributes: controller (AppControllerProtocol): The main application controller api_client (TriviaAPIClient): The API client categories (dict[str, str]): The trivia categories current_question (Question | None): The current question questions (list[Question]): The list of questions for the current game score (int): The current score TYPE_MAPPING (ClassVar[dict[str, str | None]]): Mapping of question types to API-compatible values DIFFICULTY_MULTIPLIER (ClassVar[dict[str, int]]): Difficulty level multipliers</p> Source code in <code>trivia_game/quiz_brain.py</code> <pre><code>def __init__(self, controller: AppControllerProtocol) -&gt; None:\n    \"\"\"Create the quiz brain object\n\n    Args:\n        controller (AppControllerProtocol): The main application controller\n\n    Attributes:\n    controller (AppControllerProtocol): The main application controller\n    api_client (TriviaAPIClient): The API client\n    categories (dict[str, str]): The trivia categories\n    current_question (Question | None): The current question\n    questions (list[Question]): The list of questions for the current game\n    score (int): The current score\n    TYPE_MAPPING (ClassVar[dict[str, str | None]]): Mapping of question types to API-compatible values\n    DIFFICULTY_MULTIPLIER (ClassVar[dict[str, int]]): Difficulty level multipliers\n    \"\"\"\n\n    self.controller: AppControllerProtocol = controller\n    self.api_client: TriviaAPIClient = TriviaAPIClient()\n\n    self.categories: dict[str, str] = {}\n    self.current_question: Question | None = None\n    self.questions: list[Question] = []\n    self.score: int = 0\n\n    self._load_categories()\n</code></pre>"},{"location":"modules/#trivia_game.quiz_brain.QuizBrain.check_answer","title":"<code>check_answer(selected_answer)</code>","text":"<p>Check if selected answer is correct</p> <p>Parameters:</p> Name Type Description Default <code>selected_answer</code> <code>str</code> <p>The selected answer</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if correct, False otherwise</p> Source code in <code>trivia_game/quiz_brain.py</code> <pre><code>def check_answer(self, selected_answer: str) -&gt; bool:\n    \"\"\"Check if selected answer is correct\n\n    Args:\n        selected_answer (str): The selected answer\n\n    Returns:\n        bool: True if correct, False otherwise\n    \"\"\"\n    if not self.current_question:\n        return False\n\n    is_correct: bool = selected_answer == self.current_question.correct_answer\n\n    if is_correct:\n        self.score += self._calculate_score(self.current_question.difficulty)\n    return is_correct\n</code></pre>"},{"location":"modules/#trivia_game.quiz_brain.QuizBrain.end_game","title":"<code>end_game()</code>","text":"<p>Handle game completion</p> Source code in <code>trivia_game/quiz_brain.py</code> <pre><code>def end_game(self) -&gt; None:\n    \"\"\"Handle game completion\"\"\"\n\n    dialog: ScoreDialog = ScoreDialog(self.controller, self.score)\n    if player_name := dialog.get_input():\n        self.save_score(player_name)\n\n        self.score = 0\n    self.controller.show_frame(\"ScoreboardFrame\")\n</code></pre>"},{"location":"modules/#trivia_game.quiz_brain.QuizBrain.get_available_categories","title":"<code>get_available_categories()</code>","text":"<p>Get list of available categories including 'Any Category' option</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: The categories with the 'Any Category' option</p> Source code in <code>trivia_game/quiz_brain.py</code> <pre><code>def get_available_categories(self) -&gt; list[str]:\n    \"\"\"Get list of available categories including 'Any Category' option\n\n    Returns:\n        list[str]: The categories with the 'Any Category' option\n    \"\"\"\n    categories: list[str] = [\"Any Category\"]\n    categories.extend(sorted(self.categories.keys()))\n\n    return categories\n</code></pre>"},{"location":"modules/#trivia_game.quiz_brain.QuizBrain.get_available_difficulties","title":"<code>get_available_difficulties()</code>","text":"<p>Get list of available difficulty levels</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: The difficulties</p> Source code in <code>trivia_game/quiz_brain.py</code> <pre><code>def get_available_difficulties(self) -&gt; list[str]:\n    \"\"\"Get list of available difficulty levels\n\n    Returns:\n        list[str]: The difficulties\n\n    \"\"\"\n    return [\"Any Difficulty\", \"Easy\", \"Medium\", \"Hard\"]\n</code></pre>"},{"location":"modules/#trivia_game.quiz_brain.QuizBrain.get_available_question_types","title":"<code>get_available_question_types()</code>","text":"<p>Get list of available question types</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: The question types</p> Source code in <code>trivia_game/quiz_brain.py</code> <pre><code>def get_available_question_types(self) -&gt; list[str]:\n    \"\"\"Get list of available question types\n\n    Returns:\n        list[str]: The question types\n\n    \"\"\"\n    return [\"Any Type\", \"Multiple Choice\", \"True / False\"]\n</code></pre>"},{"location":"modules/#trivia_game.quiz_brain.QuizBrain.get_category_id","title":"<code>get_category_id(category_name)</code>","text":"<p>Get category ID for selected category name</p> <p>Parameters:</p> Name Type Description Default <code>category_name</code> <code>str</code> <p>The category name</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The category ID or None if 'Any Category'</p> Source code in <code>trivia_game/quiz_brain.py</code> <pre><code>def get_category_id(self, category_name: str) -&gt; str | None:\n    \"\"\"Get category ID for selected category name\n\n    Args:\n        category_name (str): The category name\n\n    Returns:\n        str | None: The category ID or None if 'Any Category'\n\n    \"\"\"\n    return None if category_name == \"Any Category\" else self.categories[category_name]\n</code></pre>"},{"location":"modules/#trivia_game.quiz_brain.QuizBrain.get_difficulty_value","title":"<code>get_difficulty_value(difficulty_name)</code>","text":"<p>Get API-compatible difficulty value</p> <p>Parameters:</p> Name Type Description Default <code>difficulty_name</code> <code>str</code> <p>The difficulty name</p> required <p>Returns:</p> Type Description <code>Literal['easy', 'medium', 'hard'] | None</code> <p>Literal[\"easy\", \"medium\", \"hard\"] | None: The difficulty value or None if 'Any Difficulty'</p> Source code in <code>trivia_game/quiz_brain.py</code> <pre><code>def get_difficulty_value(self, difficulty_name: str) -&gt; Literal[\"easy\", \"medium\", \"hard\"] | None:\n    \"\"\"Get API-compatible difficulty value\n\n    Args:\n        difficulty_name (str): The difficulty name\n\n    Returns:\n        Literal[\"easy\", \"medium\", \"hard\"] | None: The difficulty value or None if 'Any Difficulty'\n    \"\"\"\n    return None if difficulty_name == \"Any Difficulty\" else difficulty_name.lower()  # type: ignore[return-value]\n</code></pre>"},{"location":"modules/#trivia_game.quiz_brain.QuizBrain.get_question_type_value","title":"<code>get_question_type_value(question_type)</code>","text":"<p>Get API-compatible question type value</p> <p>Parameters:</p> Name Type Description Default <code>question_type</code> <code>str</code> <p>The question type</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The question type value or None if 'Any Type'</p> Source code in <code>trivia_game/quiz_brain.py</code> <pre><code>def get_question_type_value(self, question_type: str) -&gt; str | None:\n    \"\"\"Get API-compatible question type value\n\n    Args:\n        question_type (str): The question type\n\n    Returns:\n        str | None: The question type value or None if 'Any Type'\n\n    \"\"\"\n    return self.TYPE_MAPPING[question_type]\n</code></pre>"},{"location":"modules/#trivia_game.quiz_brain.QuizBrain.load_questions","title":"<code>load_questions(category, difficulty, question_type)</code>","text":"<p>Load questions from the API</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str | None</code> <p>The category ID or None for 'Any Category'</p> required <code>difficulty</code> <code>Literal['easy', 'medium', 'hard'] | None</code> <p>The difficulty level or None for 'Any Difficulty'</p> required <code>question_type</code> <code>Literal['multiple', 'boolean'] | None</code> <p>The question type or None for 'Any Type'</p> required Source code in <code>trivia_game/quiz_brain.py</code> <pre><code>def load_questions(\n    self,\n    category: str | None,\n    difficulty: Literal[\"easy\", \"medium\", \"hard\"] | None,\n    question_type: Literal[\"multiple\", \"boolean\"] | None,\n) -&gt; None:\n    \"\"\"Load questions from the API\n\n    Args:\n        category (str | None): The category ID or None for 'Any Category'\n        difficulty (Literal[\"easy\", \"medium\", \"hard\"] | None): The difficulty level or None for 'Any Difficulty'\n        question_type (Literal[\"multiple\", \"boolean\"] | None): The question type or None for 'Any Type'\n    \"\"\"\n    try:\n        self.questions = self.api_client.fetch_questions(\n            category=category, difficulty=difficulty, question_type=question_type\n        )\n        self.score = 0\n        self.show_next_question()\n    except Exception as e:\n        msg: str = f\"Error loading questions: {e}\"\n        self.controller.show_error(msg)\n</code></pre>"},{"location":"modules/#trivia_game.quiz_brain.QuizBrain.save_score","title":"<code>save_score(player_name)</code>","text":"<p>Save score to the scoreboard</p> Source code in <code>trivia_game/quiz_brain.py</code> <pre><code>def save_score(self, player_name: str) -&gt; None:\n    \"\"\"Save score to the scoreboard\"\"\"\n    entry = ScoreboardEntry(player_name, self.score, date=datetime.now())\n    print(entry)  # TODO: Remove debug print\n    self._save_to_json(entry)\n</code></pre>"},{"location":"modules/#trivia_game.quiz_brain.QuizBrain.show_next_question","title":"<code>show_next_question()</code>","text":"<p>Show next question or end game if no more questions</p> Source code in <code>trivia_game/quiz_brain.py</code> <pre><code>def show_next_question(self) -&gt; None:\n    \"\"\"Show next question or end game if no more questions\"\"\"\n    if not self.questions:\n        print(\"No more questions, showing scoreboard\")  # TODO: Remove debug print\n        self.end_game()\n        return\n\n    self.current_question = self.questions.pop(0)\n    self.controller.show_frame(\n        \"TrueFalseQuizFrame\" if self.current_question.type == \"boolean\" else \"MultipleChoiceQuizFrame\"\n    )\n</code></pre>"},{"location":"modules/#trivia_game.trivia_api.TriviaAPIClient","title":"<code>TriviaAPIClient</code>","text":"<p>Client for handling Trivia API interactions</p> <p>Attributes:</p> Name Type Description <code>QUESTIONS_API_URL</code> <code>ClassVar[str]</code> <p>The URL for fetching questions</p> <code>SESSION_TOKEN_API_URL</code> <code>ClassVar[str]</code> <p>The URL for fetching session tokens</p> <code>CATEGORIES_API_URL</code> <code>str</code> <p>The URL for fetching categories</p> <code>ERROR_MESSAGES</code> <code>ClassVar[dict[int, str]]</code> <p>Error messages for API response codes</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Timeout for requests. Defaults to 10.</p> <code>10</code> <code>retries</code> <code>int</code> <p>Number of retries for failed requests. Defaults to 3.</p> <code>3</code> <p>Raises:</p> Type Description <code>TriviaAPIError</code> <p>If an unknown error occurs</p> <code>NoResultsError</code> <p>If there are not enough questions available</p> <code>InvalidParameterError</code> <p>If invalid parameters are provided</p> <code>TokenError</code> <p>If a session token is not found or is empty</p> <code>RateLimitError</code> <p>If the rate limit is exceeded</p> Source code in <code>trivia_game/trivia_api.py</code> <pre><code>class TriviaAPIClient:\n    \"\"\"Client for handling Trivia API interactions\n\n    Attributes:\n        QUESTIONS_API_URL (ClassVar[str]): The URL for fetching questions\n        SESSION_TOKEN_API_URL (ClassVar[str]): The URL for fetching session tokens\n        CATEGORIES_API_URL (str): The URL for fetching categories\n        ERROR_MESSAGES (ClassVar[dict[int, str]]): Error messages for API response codes\n\n    Args:\n        timeout (int, optional): Timeout for requests. Defaults to 10.\n        retries (int, optional): Number of retries for failed requests. Defaults to 3.\n\n    Raises:\n        TriviaAPIError: If an unknown error occurs\n        NoResultsError: If there are not enough questions available\n        InvalidParameterError: If invalid parameters are provided\n        TokenError: If a session token is not found or is empty\n        RateLimitError: If the rate limit is exceeded\n    \"\"\"\n\n    QUESTIONS_API_URL: ClassVar[str] = \"https://opentdb.com/api.php\"\n    SESSION_TOKEN_API_URL: ClassVar[str] = \"https://opentdb.com/api_token.php\"\n    CATEGORIES_API_URL: ClassVar[str] = \"https://opentdb.com/api_category.php\"\n\n    ERROR_MESSAGES: ClassVar[dict[int, str]] = {\n        TriviaResponseCode.NO_RESULTS: \"Not enough questions available for your query\",\n        TriviaResponseCode.INVALID_PARAMETER: \"Invalid parameters provided\",\n        TriviaResponseCode.TOKEN_NOT_FOUND: \"Session token not found\",\n        TriviaResponseCode.TOKEN_EMPTY: \"Token has returned all possible questions\",\n        TriviaResponseCode.RATE_LIMIT: \"Rate limit exceeded. Please wait 5 seconds\",\n    }\n\n    HTTP_ERROR_MAPPING: ClassVar[dict[int, tuple[type[Exception], str]]] = {\n        400: (InvalidParameterError, \"Bad Request\"),\n        401: (TriviaAPIError, \"Authentication required\"),\n        403: (TriviaAPIError, \"Access denied\"),\n        404: (TriviaAPIError, \"Resource not found\"),\n        429: (RateLimitError, \"Rate limit exceeded\"),\n        500: (TriviaAPIError, \"Internal Server Error\"),\n        502: (TriviaAPIError, \"Bad Gateway\"),\n        503: (TriviaAPIError, \"Service Unavailable\"),\n        504: (TriviaAPIError, \"Gateway Timeout\"),\n    }\n\n    REQUEST_ERROR_MAPPING: ClassVar[dict[type[Exception], tuple[type[Exception], str]]] = {\n        requests.exceptions.ConnectionError: (TriviaAPIError, \"Connection error\"),\n        requests.exceptions.Timeout: (TriviaAPIError, \"Request timed out\"),\n        requests.exceptions.JSONDecodeError: (TriviaAPIError, \"Invalid JSON response\"),\n        requests.exceptions.RequestException: (TriviaAPIError, \"Generic error\"),\n    }\n\n    def __init__(self, timeout: int = 10, retries: int = 3) -&gt; None:\n        \"\"\"Initialize the TriviaAPIClient\n\n        Args:\n            timeout (int, optional): Timeout for requests. Defaults to 10.\n            retries (int, optional): Number of retries for failed requests. Defaults to 3.\n\n        Returns:\n            None\n        \"\"\"\n\n        self.timeout = timeout\n        self._session_token: str | None = None\n        self.session = self._create_session(retries)\n        self._session_token = self.request_session_token()\n        self.categories: dict[str, str] = {}\n\n    def _create_session(self, retries: int) -&gt; requests.Session:\n        \"\"\"Create and configure requests session\n\n        Args:\n            retries (int): Number of retries for failed requests\n\n        Returns:\n            requests.Session: The configured session\n        \"\"\"\n        session: requests.Session = requests.Session()\n\n        retry_strategy: Retry = Retry(\n            total=retries,\n            backoff_factor=5,\n            status_forcelist=[429, 500, 502, 503, 504],\n            allowed_methods=[\"GET\"],\n        )\n        adapter: HTTPAdapter = HTTPAdapter(max_retries=retry_strategy)\n        session.mount(\"http://\", adapter)\n        session.mount(\"https://\", adapter)\n        return session\n\n    def _handle_response_code(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"Handle response code from Trivia API\n\n        Args:\n            data (dict[str, Any]): The JSON response data\n\n        Raises:\n            TriviaAPIError: If an unknown error occurs\n            NoResultsError: If there are not enough questions available\n            InvalidParameterError: If invalid parameters are provided\n            TokenError: If a session token is not found or is empty\n            RateLimitError: If the rate limit is exceeded\n\n        Returns:\n            None\n        \"\"\"\n        response_code: int | None = data.get(\"response_code\")\n\n        if response_code is None:\n            msg: str = \"Response code not found in API response\"\n            raise TriviaAPIError(msg)\n\n        if response_code == TriviaResponseCode.SUCCESS:\n            return\n\n        error_message = self.ERROR_MESSAGES.get(response_code, f\"Unknown error occurred: {response_code}\")\n\n        if response_code == TriviaResponseCode.NO_RESULTS:\n            raise NoResultsError(error_message)\n        elif response_code == TriviaResponseCode.INVALID_PARAMETER:\n            raise InvalidParameterError(error_message)\n        elif response_code in (TriviaResponseCode.TOKEN_NOT_FOUND, TriviaResponseCode.TOKEN_EMPTY):\n            raise TokenError(error_message)\n        elif response_code == TriviaResponseCode.RATE_LIMIT:\n            raise RateLimitError(error_message)\n        else:\n            raise TriviaAPIError(error_message)\n\n    def _parse_and_validate_response(self, response: requests.Response) -&gt; dict[str, Any]:\n        \"\"\"Parse and validate JSON response from API\n\n        Args:\n            response (requests.Response): The HTTP response object\n\n        Raises:\n            TriviaAPIError: If the JSON response is invalid\n\n        Returns:\n            dict[str, Any]: The JSON response data\n        \"\"\"\n        try:\n            data: dict[str, Any] = response.json()\n\n        except requests.exceptions.JSONDecodeError as e:\n            error_msg: str = f\"Invalid JSON response: {e!s}\"\n            raise TriviaAPIError(error_msg) from e\n\n        if \"response_code\" in data:\n            self._handle_response_code(data)\n\n        # Check for empty token only if token field exists\n        if \"token\" in data and not data[\"token\"]:\n            token_err_msg: str = \"Invalid token received\"\n            raise TokenError(token_err_msg)\n\n        return data\n\n    def _make_request(self, url: str, params: dict[str, Any] | None = None) -&gt; dict[str, Any]:\n        \"\"\"Make HTTP request with error handling\"\"\"\n\n        try:\n            response: requests.Response = self.session.get(url, params=params, timeout=self.timeout)\n            response.raise_for_status()\n\n        except requests.exceptions.HTTPError as e:\n            status_code: int = e.response.status_code\n            error_class, error_msg = self.HTTP_ERROR_MAPPING.get(status_code, (TriviaAPIError, f\"HTTP {status_code}\"))\n            http_err_msg: str = f\"Request failed: {error_msg}\"\n            raise error_class(http_err_msg) from e\n\n        except tuple(self.REQUEST_ERROR_MAPPING.keys()) as e:\n            error_class, error_msg = self.REQUEST_ERROR_MAPPING[type(e)]\n            request_err_msg: str = f\"Request failed: {error_msg}\"\n            raise error_class(request_err_msg) from e\n\n        else:\n            return self._parse_and_validate_response(response)\n\n    def request_session_token(self) -&gt; str:\n        \"\"\"Request a session token from the API\n\n        Raises:\n            TriviaAPIError: If the request fails\n\n        Returns:\n            str: The session token value\n        \"\"\"\n        params: dict[str, str] = {\"command\": \"request\"}\n        data: dict[str, Any] = self._make_request(self.SESSION_TOKEN_API_URL, params=params)\n        return cast(str, data[\"token\"])\n\n    def reset_session_token(self) -&gt; str:\n        \"\"\"Reset the current session token.\n\n        This will wipe all progress/question history for the current token\n        but return the same token value. Use this when you've exhausted\n        all questions for a given category/difficulty combination.\n\n        Raises:\n            TokenError: If no active session token exists\n            TriviaAPIError: If the reset request fails\n\n        Returns:\n            str: The same token value, but with progress wiped\n        \"\"\"\n        if not self._session_token:\n            msg: str = \"Cannot reset: No active session token\"\n            raise TokenError(msg)\n\n        params: dict[str, str] = {\"command\": \"reset\", \"token\": self._session_token}\n        data: dict[str, Any] = self._make_request(self.SESSION_TOKEN_API_URL, params=params)\n        return cast(str, data[\"token\"])\n\n    def _validate_token(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"Validate the session token in the API response\n\n        Args:\n            data (dict[str, Any]): The API response data\n\n        Raises:\n            TokenError: If the token is invalid or empty\n\n        Returns:\n            None\n        \"\"\"\n        if \"token\" in data and not data[\"token\"]:\n            msg: str = \"Invalid token received\"\n            raise TokenError(msg)\n\n    @staticmethod\n    def _decode_text(text: str) -&gt; str:\n        \"\"\"Decode URL-encoded text\n\n        Args:\n            text (str): The URL-encoded text\n\n        Returns:\n            str: The decoded text\n        \"\"\"\n        return html.unescape(unquote(text))\n\n    def _format_question(self, data: dict[str, Any]) -&gt; Question:\n        \"\"\"Format and decode question data from API response\n\n        Args:\n            data (dict[str, Any]): The question data from the API\n\n        Returns:\n            Question: The formatted question object\n        \"\"\"\n        difficulty: str = self._decode_text(data[\"difficulty\"])\n\n        if difficulty not in (\"easy\", \"medium\", \"hard\"):\n            difficulty_err_msg: str = f\"Invalid difficulty value: {difficulty}\"\n            raise InvalidParameterError(difficulty_err_msg)\n\n        return Question(\n            type=cast(QuestionType, self._decode_text(data[\"type\"])),\n            difficulty=cast(DifficultyType, difficulty),\n            category=self._decode_text(data[\"category\"]),\n            question=self._decode_text(data[\"question\"]),\n            correct_answer=self._decode_text(data[\"correct_answer\"]),\n            incorrect_answers=[self._decode_text(answer) for answer in data[\"incorrect_answers\"]],\n        )\n\n    def fetch_categories(self) -&gt; dict[str, str]:\n        \"\"\"Fetch trivia categories from the API\n\n        Raises:\n            CategoryError: If the request fails or no categories are found\n\n        Returns:\n            dict[str, str]: The categories as a dict of name: id\n        \"\"\"\n\n        try:\n            data = self._make_request(self.CATEGORIES_API_URL)\n\n            if not data.get(\"trivia_categories\"):\n                category_error_msg = \"No categories found in API response\"\n                raise CategoryError(category_error_msg)\n\n            self.categories = {\n                category[\"name\"]: str(category[\"id\"])\n                for category in data[\"trivia_categories\"]\n                if category.get(\"name\") and category.get(\"id\")\n            }\n\n        except TriviaAPIError as e:\n            error_msg: str = f\"Failed to fetch categories: {e!s}\"\n            raise CategoryError(error_msg) from e\n\n        else:\n            return self.categories\n\n    def fetch_questions(\n        self,\n        amount: int = 10,\n        category: str | None = None,\n        difficulty: DifficultyType | None = None,\n        question_type: QuestionType | None = None,\n        max_retries: int = 3,\n    ) -&gt; list[Question]:\n        \"\"\"Fetch trivia questions from the API.\n\n        Args:\n            amount (int, optional): The number of questions to fetch. Defaults to 10.\n            category (str, optional): The category to fetch questions from. Defaults to None.\n            difficulty (str, optional): The difficulty level of the questions. Defaults to None.\n            question_type (str, optional): The type of questions to fetch. Defaults to None.\n            max_retries (int, optional): The maximum number of retries for token reset. Defaults to 3.\n        Raises:\n            InvalidParameterError: If invalid parameters are provided\n            TokenError: If the session token is not found or is empty\n            NoResultsError: If there are not enough questions available\n            RateLimitError: If the rate limit is exceeded\n\n        Returns:\n            list[Question]: The list of formatted question objects\n        \"\"\"\n\n        if amount &lt; 1 or amount &gt; 50:\n            msg: str = \"Amount must be between 1 and 50\"\n            raise InvalidParameterError(msg)\n\n        params: dict[str, str | None] = {\n            \"amount\": str(amount),\n            \"token\": self._session_token,\n        }\n\n        if category:\n            params[\"category\"] = category\n        if difficulty:\n            params[\"difficulty\"] = difficulty\n        if question_type:\n            params[\"type\"] = question_type\n\n        retry_count: int = 0\n        retry_count_err_msg: str = \"Maximum retry attempts reached for token reset\"\n\n        while retry_count &lt;= max_retries:\n            try:\n                data: dict[str, Any] = self._make_request(self.QUESTIONS_API_URL, params=params)\n\n            except TokenError as e:\n                if \"Token has returned all possible questions\" not in str(e):\n                    raise\n                if retry_count &gt;= max_retries:\n                    raise TokenError(retry_count_err_msg) from e\n                self._session_token = self.reset_session_token()\n                retry_count += 1\n            else:\n                return [self._format_question(question) for question in data[\"results\"]]\n\n        raise TokenError(retry_count_err_msg)\n\n    def __enter__(self) -&gt; \"TriviaAPIClient\":\n        \"\"\"Enter context manager\n\n        Returns:\n            TriviaAPIClient: The client instance\n        \"\"\"\n        return self\n\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None\n    ) -&gt; None:\n        \"\"\"Close the session when exiting the context manager.\n\n        Args:\n            exc_type: The type of the exception that was raised\n            exc_val: The instance of the exception that was raised\n            exc_tb: The traceback of the exception that was raised\n\n        Returns:\n            None\n        \"\"\"\n        self.session.close()\n</code></pre>"},{"location":"modules/#trivia_game.trivia_api.TriviaAPIClient.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter context manager</p> <p>Returns:</p> Name Type Description <code>TriviaAPIClient</code> <code>TriviaAPIClient</code> <p>The client instance</p> Source code in <code>trivia_game/trivia_api.py</code> <pre><code>def __enter__(self) -&gt; \"TriviaAPIClient\":\n    \"\"\"Enter context manager\n\n    Returns:\n        TriviaAPIClient: The client instance\n    \"\"\"\n    return self\n</code></pre>"},{"location":"modules/#trivia_game.trivia_api.TriviaAPIClient.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Close the session when exiting the context manager.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>type[BaseException] | None</code> <p>The type of the exception that was raised</p> required <code>exc_val</code> <code>BaseException | None</code> <p>The instance of the exception that was raised</p> required <code>exc_tb</code> <code>TracebackType | None</code> <p>The traceback of the exception that was raised</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>trivia_game/trivia_api.py</code> <pre><code>def __exit__(\n    self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None\n) -&gt; None:\n    \"\"\"Close the session when exiting the context manager.\n\n    Args:\n        exc_type: The type of the exception that was raised\n        exc_val: The instance of the exception that was raised\n        exc_tb: The traceback of the exception that was raised\n\n    Returns:\n        None\n    \"\"\"\n    self.session.close()\n</code></pre>"},{"location":"modules/#trivia_game.trivia_api.TriviaAPIClient.__init__","title":"<code>__init__(timeout=10, retries=3)</code>","text":"<p>Initialize the TriviaAPIClient</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Timeout for requests. Defaults to 10.</p> <code>10</code> <code>retries</code> <code>int</code> <p>Number of retries for failed requests. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>trivia_game/trivia_api.py</code> <pre><code>def __init__(self, timeout: int = 10, retries: int = 3) -&gt; None:\n    \"\"\"Initialize the TriviaAPIClient\n\n    Args:\n        timeout (int, optional): Timeout for requests. Defaults to 10.\n        retries (int, optional): Number of retries for failed requests. Defaults to 3.\n\n    Returns:\n        None\n    \"\"\"\n\n    self.timeout = timeout\n    self._session_token: str | None = None\n    self.session = self._create_session(retries)\n    self._session_token = self.request_session_token()\n    self.categories: dict[str, str] = {}\n</code></pre>"},{"location":"modules/#trivia_game.trivia_api.TriviaAPIClient.fetch_categories","title":"<code>fetch_categories()</code>","text":"<p>Fetch trivia categories from the API</p> <p>Raises:</p> Type Description <code>CategoryError</code> <p>If the request fails or no categories are found</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: The categories as a dict of name: id</p> Source code in <code>trivia_game/trivia_api.py</code> <pre><code>def fetch_categories(self) -&gt; dict[str, str]:\n    \"\"\"Fetch trivia categories from the API\n\n    Raises:\n        CategoryError: If the request fails or no categories are found\n\n    Returns:\n        dict[str, str]: The categories as a dict of name: id\n    \"\"\"\n\n    try:\n        data = self._make_request(self.CATEGORIES_API_URL)\n\n        if not data.get(\"trivia_categories\"):\n            category_error_msg = \"No categories found in API response\"\n            raise CategoryError(category_error_msg)\n\n        self.categories = {\n            category[\"name\"]: str(category[\"id\"])\n            for category in data[\"trivia_categories\"]\n            if category.get(\"name\") and category.get(\"id\")\n        }\n\n    except TriviaAPIError as e:\n        error_msg: str = f\"Failed to fetch categories: {e!s}\"\n        raise CategoryError(error_msg) from e\n\n    else:\n        return self.categories\n</code></pre>"},{"location":"modules/#trivia_game.trivia_api.TriviaAPIClient.fetch_questions","title":"<code>fetch_questions(amount=10, category=None, difficulty=None, question_type=None, max_retries=3)</code>","text":"<p>Fetch trivia questions from the API.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>The number of questions to fetch. Defaults to 10.</p> <code>10</code> <code>category</code> <code>str</code> <p>The category to fetch questions from. Defaults to None.</p> <code>None</code> <code>difficulty</code> <code>str</code> <p>The difficulty level of the questions. Defaults to None.</p> <code>None</code> <code>question_type</code> <code>str</code> <p>The type of questions to fetch. Defaults to None.</p> <code>None</code> <code>max_retries</code> <code>int</code> <p>The maximum number of retries for token reset. Defaults to 3.</p> <code>3</code> <p>Raises:     InvalidParameterError: If invalid parameters are provided     TokenError: If the session token is not found or is empty     NoResultsError: If there are not enough questions available     RateLimitError: If the rate limit is exceeded</p> <p>Returns:</p> Type Description <code>list[Question]</code> <p>list[Question]: The list of formatted question objects</p> Source code in <code>trivia_game/trivia_api.py</code> <pre><code>def fetch_questions(\n    self,\n    amount: int = 10,\n    category: str | None = None,\n    difficulty: DifficultyType | None = None,\n    question_type: QuestionType | None = None,\n    max_retries: int = 3,\n) -&gt; list[Question]:\n    \"\"\"Fetch trivia questions from the API.\n\n    Args:\n        amount (int, optional): The number of questions to fetch. Defaults to 10.\n        category (str, optional): The category to fetch questions from. Defaults to None.\n        difficulty (str, optional): The difficulty level of the questions. Defaults to None.\n        question_type (str, optional): The type of questions to fetch. Defaults to None.\n        max_retries (int, optional): The maximum number of retries for token reset. Defaults to 3.\n    Raises:\n        InvalidParameterError: If invalid parameters are provided\n        TokenError: If the session token is not found or is empty\n        NoResultsError: If there are not enough questions available\n        RateLimitError: If the rate limit is exceeded\n\n    Returns:\n        list[Question]: The list of formatted question objects\n    \"\"\"\n\n    if amount &lt; 1 or amount &gt; 50:\n        msg: str = \"Amount must be between 1 and 50\"\n        raise InvalidParameterError(msg)\n\n    params: dict[str, str | None] = {\n        \"amount\": str(amount),\n        \"token\": self._session_token,\n    }\n\n    if category:\n        params[\"category\"] = category\n    if difficulty:\n        params[\"difficulty\"] = difficulty\n    if question_type:\n        params[\"type\"] = question_type\n\n    retry_count: int = 0\n    retry_count_err_msg: str = \"Maximum retry attempts reached for token reset\"\n\n    while retry_count &lt;= max_retries:\n        try:\n            data: dict[str, Any] = self._make_request(self.QUESTIONS_API_URL, params=params)\n\n        except TokenError as e:\n            if \"Token has returned all possible questions\" not in str(e):\n                raise\n            if retry_count &gt;= max_retries:\n                raise TokenError(retry_count_err_msg) from e\n            self._session_token = self.reset_session_token()\n            retry_count += 1\n        else:\n            return [self._format_question(question) for question in data[\"results\"]]\n\n    raise TokenError(retry_count_err_msg)\n</code></pre>"},{"location":"modules/#trivia_game.trivia_api.TriviaAPIClient.request_session_token","title":"<code>request_session_token()</code>","text":"<p>Request a session token from the API</p> <p>Raises:</p> Type Description <code>TriviaAPIError</code> <p>If the request fails</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The session token value</p> Source code in <code>trivia_game/trivia_api.py</code> <pre><code>def request_session_token(self) -&gt; str:\n    \"\"\"Request a session token from the API\n\n    Raises:\n        TriviaAPIError: If the request fails\n\n    Returns:\n        str: The session token value\n    \"\"\"\n    params: dict[str, str] = {\"command\": \"request\"}\n    data: dict[str, Any] = self._make_request(self.SESSION_TOKEN_API_URL, params=params)\n    return cast(str, data[\"token\"])\n</code></pre>"},{"location":"modules/#trivia_game.trivia_api.TriviaAPIClient.reset_session_token","title":"<code>reset_session_token()</code>","text":"<p>Reset the current session token.</p> <p>This will wipe all progress/question history for the current token but return the same token value. Use this when you've exhausted all questions for a given category/difficulty combination.</p> <p>Raises:</p> Type Description <code>TokenError</code> <p>If no active session token exists</p> <code>TriviaAPIError</code> <p>If the reset request fails</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The same token value, but with progress wiped</p> Source code in <code>trivia_game/trivia_api.py</code> <pre><code>def reset_session_token(self) -&gt; str:\n    \"\"\"Reset the current session token.\n\n    This will wipe all progress/question history for the current token\n    but return the same token value. Use this when you've exhausted\n    all questions for a given category/difficulty combination.\n\n    Raises:\n        TokenError: If no active session token exists\n        TriviaAPIError: If the reset request fails\n\n    Returns:\n        str: The same token value, but with progress wiped\n    \"\"\"\n    if not self._session_token:\n        msg: str = \"Cannot reset: No active session token\"\n        raise TokenError(msg)\n\n    params: dict[str, str] = {\"command\": \"reset\", \"token\": self._session_token}\n    data: dict[str, Any] = self._make_request(self.SESSION_TOKEN_API_URL, params=params)\n    return cast(str, data[\"token\"])\n</code></pre>"},{"location":"modules/#trivia_game.view.frames.base_frame.BaseFrame","title":"<code>BaseFrame</code>","text":"<p>               Bases: <code>CTkFrame</code></p> <p>Base class for all frames with common functionality</p> Source code in <code>trivia_game/view/frames/base_frame.py</code> <pre><code>class BaseFrame(ctk.CTkFrame):\n    \"\"\"Base class for all frames with common functionality\"\"\"\n\n    def __init__(self, parent: ctk.CTkFrame, controller: AppControllerProtocol) -&gt; None:\n        \"\"\"Create the base frame\n\n        Args:\n            parent (ctk.CTkFrame): The parent frame\n            controller (AppControllerProtocol): The main application controller\n        \"\"\"\n\n        super().__init__(parent)\n        self.controller = controller\n        self._setup_grid()\n        self._create_widgets()\n\n    def _setup_grid(self) -&gt; None:\n        \"\"\"Configure grid layout - override in subclasses\"\"\"\n        pass\n\n    def _create_widgets(self) -&gt; None:\n        \"\"\"Create and place widgets - override in subclasses\"\"\"\n        pass\n</code></pre>"},{"location":"modules/#trivia_game.view.frames.base_frame.BaseFrame.__init__","title":"<code>__init__(parent, controller)</code>","text":"<p>Create the base frame</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>CTkFrame</code> <p>The parent frame</p> required <code>controller</code> <code>AppControllerProtocol</code> <p>The main application controller</p> required Source code in <code>trivia_game/view/frames/base_frame.py</code> <pre><code>def __init__(self, parent: ctk.CTkFrame, controller: AppControllerProtocol) -&gt; None:\n    \"\"\"Create the base frame\n\n    Args:\n        parent (ctk.CTkFrame): The parent frame\n        controller (AppControllerProtocol): The main application controller\n    \"\"\"\n\n    super().__init__(parent)\n    self.controller = controller\n    self._setup_grid()\n    self._create_widgets()\n</code></pre>"},{"location":"modules/#trivia_game.view.frames.quiz_frames.BaseQuizFrame","title":"<code>BaseQuizFrame</code>","text":"<p>               Bases: <code>BaseFrame</code></p> <p>Base class for quiz question frames</p> Source code in <code>trivia_game/view/frames/quiz_frames.py</code> <pre><code>class BaseQuizFrame(BaseFrame):\n    \"\"\"Base class for quiz question frames\"\"\"\n\n    def _setup_grid(self) -&gt; None:\n        \"\"\"Configure grid layout\"\"\"\n        self.grid_rowconfigure((0, 4), weight=1)  # Top and bottom spacing\n        self.grid_rowconfigure((1, 2, 3), weight=0)  # Content rows\n        self.grid_columnconfigure((0, 2), weight=1)  # Side spacing\n        self.grid_columnconfigure(1, weight=0)  # Center content\n\n    def _create_widgets(self) -&gt; None:\n        \"\"\"Create and place widgets\"\"\"\n        self._clear_previous_widgets()\n        self._create_score_label()\n        self._create_question_frame()\n        self._create_question_label()\n        self.display_question()\n\n    def _create_question_frame(self) -&gt; None:\n        \"\"\"Create and place frame for question\"\"\"\n        self.question_frame = ctk.CTkFrame(self, fg_color=(\"gray85\", \"gray25\"))\n        self.question_frame.grid(row=2, column=1, pady=20, padx=40, sticky=\"nsew\")\n\n    def _create_question_label(self) -&gt; None:\n        \"\"\"Create and place question label\"\"\"\n        self.question_label = ctk.CTkLabel(\n            self.question_frame, text=\"Question text here\", wraplength=600, pady=20, padx=20\n        )\n        self.question_label.grid(row=0, column=0, sticky=\"nsew\")\n\n    def _create_answer_buttons(self) -&gt; None:\n        \"\"\"Create answer buttons - to be implemented by child classes\"\"\"\n        raise NotImplementedError(\"Child classes must implement _create_answer_buttons\")\n\n    def _handle_answer(self, answer: str) -&gt; None:\n        \"\"\"Handle user's answer selection. Base implementation - override in subclasses if needed\n\n        Args:\n            answer (str): The selected answer\n        \"\"\"\n        is_correct = self.controller.quiz_brain.check_answer(answer)\n\n        # Update score display\n        self.update_score()\n\n        # Show visual feedback\n        self.question_frame.configure(fg_color=\"green\" if is_correct else \"red\")\n        # Wait and continue\n        self.after(1000, lambda _=None: self._reset_and_continue())\n\n    def _reset_and_continue(self) -&gt; None:\n        \"\"\"Reset frame color and show next question\"\"\"\n        self.question_frame.configure(fg_color=(\"gray85\", \"gray25\"))\n        self.controller.quiz_brain.show_next_question()\n\n    def display_question(self) -&gt; None:\n        \"\"\"Display current question\"\"\"\n        if current_question := self.controller.quiz_brain.current_question:\n            question_text = current_question.question\n            self.question_label.configure(text=question_text)\n\n    def refresh(self) -&gt; None:\n        \"\"\"Refresh frame content. Base implementation - override in subclasses if needed\"\"\"\n        self.display_question()\n        self._create_answer_buttons()\n\n    def _clear_previous_widgets(self) -&gt; None:\n        \"\"\"Clear all widgets except the question frame\"\"\"\n        for widget in self.winfo_children():\n            if isinstance(widget, ctk.CTkFrame) and widget != self.question_frame:\n                widget.destroy()\n\n    def _create_score_label(self) -&gt; None:\n        \"\"\"Create and place score label\"\"\"\n        self.score_label: ctk.CTkLabel = ctk.CTkLabel(\n            self, text=f\"Score: {self.controller.quiz_brain.score}\", font=(\"Arial\", 16, \"bold\")\n        )\n        self.score_label.grid(row=1, column=1, pady=10)\n\n    def update_score(self) -&gt; None:\n        \"\"\"Update score label\"\"\"\n        self.score_label.configure(text=f\"Score: {self.controller.quiz_brain.score}\")\n</code></pre>"},{"location":"modules/#trivia_game.view.frames.quiz_frames.BaseQuizFrame.display_question","title":"<code>display_question()</code>","text":"<p>Display current question</p> Source code in <code>trivia_game/view/frames/quiz_frames.py</code> <pre><code>def display_question(self) -&gt; None:\n    \"\"\"Display current question\"\"\"\n    if current_question := self.controller.quiz_brain.current_question:\n        question_text = current_question.question\n        self.question_label.configure(text=question_text)\n</code></pre>"},{"location":"modules/#trivia_game.view.frames.quiz_frames.BaseQuizFrame.refresh","title":"<code>refresh()</code>","text":"<p>Refresh frame content. Base implementation - override in subclasses if needed</p> Source code in <code>trivia_game/view/frames/quiz_frames.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refresh frame content. Base implementation - override in subclasses if needed\"\"\"\n    self.display_question()\n    self._create_answer_buttons()\n</code></pre>"},{"location":"modules/#trivia_game.view.frames.quiz_frames.BaseQuizFrame.update_score","title":"<code>update_score()</code>","text":"<p>Update score label</p> Source code in <code>trivia_game/view/frames/quiz_frames.py</code> <pre><code>def update_score(self) -&gt; None:\n    \"\"\"Update score label\"\"\"\n    self.score_label.configure(text=f\"Score: {self.controller.quiz_brain.score}\")\n</code></pre>"},{"location":"modules/#trivia_game.view.frames.quiz_frames.MultipleChoiceQuizFrame","title":"<code>MultipleChoiceQuizFrame</code>","text":"<p>               Bases: <code>BaseQuizFrame</code></p> Source code in <code>trivia_game/view/frames/quiz_frames.py</code> <pre><code>class MultipleChoiceQuizFrame(BaseQuizFrame):\n    def _setup_grid(self) -&gt; None:\n        \"\"\"Configure grid layout\"\"\"\n        super()._setup_grid()\n\n    def _create_widgets(self) -&gt; None:\n        \"\"\"Create and place widgets\"\"\"\n        super()._create_widgets()\n        self._create_answer_buttons()\n\n    def _create_answer_buttons(self) -&gt; None:\n        \"\"\"Create multiple choice buttons\"\"\"\n        button_frame: ctk.CTkFrame = ctk.CTkFrame(self)\n        button_frame.grid(row=3, column=1)\n\n        if current_question := self.controller.quiz_brain.current_question:\n            answers = current_question.all_answers()\n            random.shuffle(answers)\n\n            for idx, answer in enumerate(answers):\n                row, col = divmod(idx, 2)\n                ctk.CTkButton(\n                    button_frame, text=answer, command=lambda a=answer: self._handle_answer(a), width=200\n                ).grid(row=row, column=col, padx=10, pady=10)\n</code></pre>"},{"location":"modules/#trivia_game.view.frames.quiz_frames.TrueFalseQuizFrame","title":"<code>TrueFalseQuizFrame</code>","text":"<p>               Bases: <code>BaseQuizFrame</code></p> <p>Frame for True/False quiz questions</p> Source code in <code>trivia_game/view/frames/quiz_frames.py</code> <pre><code>class TrueFalseQuizFrame(BaseQuizFrame):\n    \"\"\"Frame for True/False quiz questions\"\"\"\n\n    def _setup_grid(self) -&gt; None:\n        \"\"\"Configure grid layout\"\"\"\n        super()._setup_grid()\n\n    def _create_widgets(self) -&gt; None:\n        \"\"\"Create and place widgets\"\"\"\n        super()._create_widgets()\n        self._create_answer_buttons()\n\n    def _create_answer_buttons(self) -&gt; None:\n        \"\"\"Create True/False buttons\"\"\"\n        button_frame: ctk.CTkFrame = ctk.CTkFrame(self)\n        button_frame.grid(row=3, column=1)\n\n        if _ := self.controller.quiz_brain.current_question:\n            for text in [\"True\", \"False\"]:\n                ctk.CTkButton(button_frame, text=text, command=lambda t=text: self._handle_answer(t), width=200).grid(\n                    row=0, column=0 if text == \"True\" else 1, padx=10, pady=20\n                )\n</code></pre>"},{"location":"modules/#trivia_game.view.frames.score_board.ScoreboardFrame","title":"<code>ScoreboardFrame</code>","text":"<p>               Bases: <code>BaseFrame</code></p> Source code in <code>trivia_game/view/frames/score_board.py</code> <pre><code>class ScoreboardFrame(BaseFrame):\n    def _setup_grid(self) -&gt; None:\n        \"\"\"Configure grid layout\"\"\"\n        self.grid_rowconfigure(0, weight=1)  # Top spacing\n        self.grid_rowconfigure(2, weight=1)  # Bottom spacing\n        self.grid_columnconfigure(0, weight=1)\n\n    def _create_widgets(self) -&gt; None:\n        \"\"\"Create and place widgets\"\"\"\n        # Create scrollable frame for scores\n        self.scores_frame = ctk.CTkScrollableFrame(self)\n        self.scores_frame.grid(row=1, column=0, sticky=\"nsew\", padx=20, pady=20)\n\n        # Create back button\n        ctk.CTkButton(self, text=\"Back to Menu\", command=lambda: self.controller.show_frame(\"MainMenuFrame\")).grid(\n            row=3, column=0, pady=10\n        )\n\n        self.load_scores()\n\n    def load_scores(self) -&gt; None:\n        \"\"\"Load and display scores\"\"\"\n        try:\n            scores_file = Path(\"scores.json\")\n            if not scores_file.exists():\n                self._display_no_scores()\n                return\n\n            with scores_file.open() as f:\n                scores = json.load(f)\n\n            if not scores:\n                self._display_no_scores()\n                return\n\n            self._display_scores(scores)\n\n        except Exception as e:\n            self.controller.show_error(f\"Error loading scores: {e!s}\")\n            self._display_no_scores()\n\n    def _display_scores(self, scores: list[dict]) -&gt; None:\n        \"\"\"Display scores in the scrollable frame\"\"\"\n        # Clear previous widgets\n        for widget in self.scores_frame.winfo_children():\n            widget.destroy()\n\n        # Create header\n        self._create_score_row(\"Player\", \"Score\", \"Date\", is_header=True)\n\n        # Display scores\n        for score in scores:\n            self._create_score_row(score[\"player\"], str(score[\"score\"]), score[\"date\"])\n\n    def _create_score_row(self, player: str, score: str, date: str, is_header: bool = False) -&gt; None:\n        \"\"\"Create a row in the score table\"\"\"\n        font = (\"Arial\", 12, \"bold\") if is_header else (\"Arial\", 12)\n        formatted_date = date if is_header else self._format_date(date)\n\n        # Player name\n        ctk.CTkLabel(\n            self.scores_frame,\n            text=player,\n            font=font,\n            width=150,\n            anchor=\"center\",  # Center the text\n        ).grid(row=self._get_next_row(), column=0, padx=5, pady=5, sticky=\"ew\")\n\n        # Score\n        ctk.CTkLabel(\n            self.scores_frame,\n            text=score,\n            font=font,\n            width=100,\n            anchor=\"center\",  # Center the text\n        ).grid(row=self._get_current_row(), column=1, padx=5, pady=5, sticky=\"ew\")\n\n        # Date\n        ctk.CTkLabel(\n            self.scores_frame,\n            text=formatted_date,\n            font=font,\n            width=150,\n            anchor=\"center\",  # Center the text\n        ).grid(row=self._get_current_row(), column=2, padx=5, pady=5, sticky=\"ew\")\n\n    def _display_no_scores(self) -&gt; None:\n        \"\"\"Display message when no scores are available\"\"\"\n        ctk.CTkLabel(self.scores_frame, text=\"No scores available\", font=(\"Arial\", 14)).grid(\n            row=0, column=0, padx=20, pady=20\n        )\n\n    def _get_next_row(self) -&gt; int:\n        \"\"\"Get next available row in the scores frame\"\"\"\n        return len(self.scores_frame.winfo_children()) // 3\n\n    def _get_current_row(self) -&gt; int:\n        \"\"\"Get current row number\"\"\"\n        return (len(self.scores_frame.winfo_children()) - 1) // 3\n\n    def _format_date(self, date_str: str) -&gt; str:\n        \"\"\"Convert ISO format date to readable format\n\n        Args:\n            date_str (str): Date string in ISO format\n\n        Returns:\n            str: Date formatted as 'DD Month YYYY HH:MM'\n        \"\"\"\n        parsed_date = datetime.fromisoformat(date_str)\n        return parsed_date.strftime(\"%d %B %Y %H:%M\")\n\n    def refresh(self) -&gt; None:\n        \"\"\"Refresh the scoreboard display\"\"\"\n        # Clear previous widgets\n        for widget in self.scores_frame.winfo_children():\n            widget.destroy()\n\n        # Reload and display scores\n        self.load_scores()\n</code></pre>"},{"location":"modules/#trivia_game.view.frames.score_board.ScoreboardFrame.load_scores","title":"<code>load_scores()</code>","text":"<p>Load and display scores</p> Source code in <code>trivia_game/view/frames/score_board.py</code> <pre><code>def load_scores(self) -&gt; None:\n    \"\"\"Load and display scores\"\"\"\n    try:\n        scores_file = Path(\"scores.json\")\n        if not scores_file.exists():\n            self._display_no_scores()\n            return\n\n        with scores_file.open() as f:\n            scores = json.load(f)\n\n        if not scores:\n            self._display_no_scores()\n            return\n\n        self._display_scores(scores)\n\n    except Exception as e:\n        self.controller.show_error(f\"Error loading scores: {e!s}\")\n        self._display_no_scores()\n</code></pre>"},{"location":"modules/#trivia_game.view.frames.score_board.ScoreboardFrame.refresh","title":"<code>refresh()</code>","text":"<p>Refresh the scoreboard display</p> Source code in <code>trivia_game/view/frames/score_board.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refresh the scoreboard display\"\"\"\n    # Clear previous widgets\n    for widget in self.scores_frame.winfo_children():\n        widget.destroy()\n\n    # Reload and display scores\n    self.load_scores()\n</code></pre>"}]}